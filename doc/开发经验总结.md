

## 开发设计思想：

开发设计原则 来自于 设计模式。
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。
设计模式的六大原则：
+ 开闭原则（Open Close Principle）
+ 里氏代换原则（Liskov Substitution Principle）
+ 依赖倒转原则（Dependence Inversion Principle）
+ 接口隔离原则（Interface Segregation Principle）
+ 迪米特法则（最少知道原则）（Demeter Principle）
+ 合成复用原则（Composite Reuse Principle）


#### 单一职能原则

一个service只实现这个service的功能，如orderService里主要是新增订单、修改订单、查询订单等功能，并且在更新等关键地方添加日志，不要混入商品的查询、客户的查询。

- **含义**：一个类或者模块应该有且仅有一个引起它变化的原因，即一个类只负责一项职责。在这种设计中，`OrderService` 只专注于订单相关的操作，如新增订单、修改订单、查询订单等，这就是遵循单一职责原则的典型体现。它将订单管理的功能封装在一个服务中，使得该服务的职责清晰明确。
- 优点：
  - **提高可维护性**：当订单业务逻辑发生变化时，只需要修改 `OrderService` 类，不会影响到其他与商品查询、客户查询相关的功能。例如，如果订单状态的更新规则发生改变，只需在 `OrderService` 中修改相应的代码，而不会波及到商品和客户相关的服务。
  - **增强可复用性**：由于 `OrderService` 只负责订单操作，它可以在不同的场景中被复用，而不需要担心引入不必要的依赖和功能。

有些人在写代码的时候为了图方便，怎么简单怎么来，比如直接在orderService里引入customerMapper、productMapper，直接在orderService里对客户、商品进行更新，导致后期在改代码的时候，不知道会影响到哪里，orderMapper.xml里也随意写查商品、查用户等sql语句。

尤其是订单状态的更新，在新增订单或修改订单时发起流程成功后会更新状态为审批中、流程审批过程中会修改订单的状态（驳回、撤回）、审批完成回调业务接口也会改状态（已完成）、有些需求要在推送sap后修改订单的状态，有的为了解决某一问题，提供了接口由前端调用改状态，导致系统中有很多入口可以修改状态，然而状态很重要，有什么不知道在哪里改了状态，导致排查问题十分困难，但如果对修改功能进行收口，只有一个更新状态的方法，并且添加完善的日志信息，那么出现问题的时候就非常好排查。也可以使用状态机实现功能。



#### 高内聚低耦合原则

- **高内聚**：指一个模块内部各个元素之间的联系紧密，相关性强。`OrderService` 内部的新增订单、修改订单、查询订单等功能都围绕订单管理这一核心业务，它们之间的联系紧密，属于高内聚的设计。同时，在关键操作（如更新订单）的地方添加日志，进一步增强了该服务在订单管理方面的完整性和专业性。
- **低耦合**：指模块之间的依赖关系尽可能简单，一个模块的修改不会对其他模块产生重大影响。`OrderService` 不混入商品查询、客户查询等功能，避免了与商品服务、客户服务之间的过度耦合。这样，当商品服务或客户服务发生变化时，不会直接影响到 `OrderService` 的正常运行。

低耦合的代码才能更好扩展，不然后期维护，改一个地方影响了一大堆地方，导致代码根本改不动。



#### 开闭原则

开闭原则指软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭。这意味着在软件系统的生命周期中，当需要添加新功能或应对新的业务需求时，应该通过扩展现有代码来实现，而不是直接修改已有的、经过测试和验证的代码。遵循开闭原则可以使软件具有更好的可维护性和可扩展性，降低软件维护成本，减少引入新错误的风险。

比如订单有很多发货平台，每个平台推单传参的结构都不一样，如sap、oms、千易、管易，如果每新增一个平台都在原代码层面再改一遍，这容易影响到原来的代码，因此定义一个订单推单抽象类或接口，在不改原代码的前提下，新增类来实现功能。



#### 接口隔离原则

- **定义**：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。其核心思想是将庞大、复杂的接口拆分成多个粒度更细、功能更单一的接口，让客户端只依赖于它们实际需要的接口方法，避免因依赖不必要的接口而带来的耦合性和复杂性。
- 目的和优势
  - **降低耦合度**：使得各个模块或类之间的依赖关系更加清晰和简单，减少因接口变化而导致的连锁反应，提高软件的可维护性和可扩展性。
  - **提高内聚性**：每个接口专注于特定的功能，实现类只需关注并实现与自身相关的接口方法，增强了类的内聚性。
  - **增强灵活性和可复用性**：细粒度的接口更易于组合和复用，不同的客户端可以根据自身需求选择合适的接口，而不必受限于一个大而全的接口。
- 接口隔离原则可参考：设计原则：接口隔离原则（ISP）https://www.cnblogs.com/hunternet/p/14683686.html

比如订单类orderService，其实现类有一万多行，代码严重耦合，里面包含了查询订单、新增订单、修改订单、订单参数校验、导入订单（标准订单导入、一件代发订单导入）、导出订单、导出PI文件、导出CN文件、审批订单、冻结订单、查询库存、汇率转换、订单看板统计等等功能。

- 订单操作接口细分
  - **未遵循 ISP 的情况**：创建一个庞大的`OrderInterface`接口，其中包含了订单创建、查询、修改、删除、支付、发货、退款等所有与订单相关的操作方法。所有与订单处理相关的类都需要实现这个接口，例如订单管理类、支付类、物流类等。这就导致了支付类和物流类可能会依赖一些与它们无关的方法，如订单删除等，增加了不必要的耦合。
  - **遵循 ISP 的做法**：将`OrderInterface`拆分成多个小接口，如`OrderCreationInterface`（包含订单创建方法）、`OrderQueryInterface`（包含订单查询方法）、`OrderModificationInterface`（包含订单修改方法）、`OrderPaymentInterface`（包含订单支付方法）、`OrderDeliveryInterface`（包含订单发货方法）、`OrderRefundInterface`（包含订单退款方法）等。订单管理类可以实现`OrderCreationInterface`、`OrderQueryInterface`和`OrderModificationInterface`；支付类实现`OrderPaymentInterface`；物流类实现`OrderDeliveryInterface`等。这样每个类只依赖于它需要的接口，降低了耦合度。
  - **读写分离的原则**：如将订单拆分 查询（读）一个接口、更新（写）一个接口





## 单元测试的重要性：

 如果一个项目的单元测试很全面，那么如果你想修改一些功能，运行一遍单元测试就知道改动的代码对其它地方有没有影响，这也是开源项目中有非常多的单元测试案例的原因。项目在不停迭代，修改原有功能的代码很有可能导致别的地方出现问题，单元测试可以主动发现问题，并且也给其他接手项目的人了解项目功能，通过一些测试案例能发现一些特殊场景下可能存在的问题。 

单元测试可能遇到的一些问题： 

1.一些接口功能复杂，需要调用其它服务的功能。如订单系统下单会发起审批流，发起审批流会调用另外一个服务，单独执行会报错。这种情况通常在单元测试有相关的测试包来处理这种情况。 

2.单元测试的测试案例应尽量全面，如订单商品有只有单品、只有组合商品、单品和组合商品的组合等场景，需要每个都覆盖，以解决场景遗漏而没有自测出来。





## 代码规范

1. 一个类不要超过太多行，如订单一万多行，非常影响阅读和维护，最好不要超过一千行，写出机器能读懂的代码很容易，写出人能读懂的代码很难。
2. 要合理抽取方法，一个方法不要超过50行，最好不超过20行，嵌套不要太深，如十几层的if else嵌套，可以使用截断式的先返回，如不为空接着执行，那么为空就直接return
3. 代码要按功能分层、分类，如订单的功能比较复杂，可以根据订单不同功能创建不同的类，如orderQueryService、orderStatusService
4. 多个地方修改同一表数据的时候，要将功能收口到一个地方，即要做好方法抽象的能力，如订单的物流状态，订单的发货平台有SAP、OMS海外仓、千易、管易，这些平台发货后都会更新相应的物流状态，那么物流状态的判断是否需要在每个平台处理交货单时一行一行的处理状态吗？如果发货状态规则变了（要考虑冻结数量）就需要每个平台都去改一遍，而且还容易改漏。如果将物流状态发在一个方法里处理就不需要担心会改漏。但要考虑代码抽象能力，传什么参，可能会重复查询等，虽然效率会稍微慢一点，但功能会更完备，维护起来更方便。如`resolveOrderProductLogisticsStatus(String deliveryPlatform, List<OrderProductDO> orderProductDOList)`
5. 处理逻辑和保存逻辑要分开，如拉取千易订单，处理商品行，如果处理一行保存一行，这样耦合度太高，因为处理逻辑很多很复杂，比如尾差处理需要所有行都处理完才能进行计算，所以应该将所有行都处理完毕，最后才能将数据保存下来。
6. 调用外部系统，要加一个防腐层，即外部系统接口接收到的数据一般为json，如果直接用json做业务处理，实际上是不知道接口的返参是什么，每次都需要去对接口文档查字段含义，如果将接口文档中的返参作为一个对象，将接收到的json转为这个对象，那么再处理接收的数据时就非常清晰好维护。
7. 要重视历史数据的处理，否则会有一些意想不到的问题，这个功能也不是完备的。
8. 禁止在循环里查数据库，比较校验商品是否存在，对商品列表进行循环一条条查数据库是否存在，这样每次查询一次数据库，就占用一次数据库连接，如果数据量较大将非常耗时，十分影响性能。应该一次性将商品数据查出来（只使用一次数据库连接），然后在内存中判断是否存在，这样就能提高效率
9. 不要单点解决问题，最好是有一个一劳永逸的方式。比如判断订单是否是提交后的再次修改，通过业务数据发货平台来判断这个单是否已经进行了一次审批，如果存在发货平台说明这个单已经完成过一次审批，没有的话就是第一次审批，显然这里是不合适的，因为不知道在什么情况下即使审批完成了但发货平台依然是空的。或者有极少场景，审批完成是不需要选发货平台的。这时候用业务数据判断显然是不合适的，如果流程完成记录一个标记，那么就与业务无关，就能实现与业务的解耦。
10. 关键业务有异常一定要第一时间得到通知，可以在捕获异常处发送飞书消息或发邮件到负责人，这样才能快速感知异常、处理异常。
11. 接手别人的接口一定要考虑前置条件，比如一个接口本来是前端调用的，后面由后端调用，要对一些条件进行判空处理，最好和前端接口调用前的一些校验保持一致，否则由于不清楚接口内部的实现逻辑，由于参数为空引发错误。
12. 线程数过多导致线程被占满，无法处理新的请求，导致报错。订单详情由于查询较多，使用了多线程并行查询数据，但某些查询比较耗时，一直占用资源使线程阻塞，然后调用订单详情接口的使用者很多，导致线程数量不够
13. 数据库表冗余数据有两种方式：一是冗余引用，即只冗余id或code等唯一标识，通过这个标识去查询最新的数据，如名称等；二是冗余实体（或称快照），即冗余保存那一刻的数据，如保存订单时冗余当时物料的授权价、产品型号等数据。
14. 使用自定义权限时，如果想去掉权限，可以定义一个注解，如@IgnoreDataRole，这个注解应该加在接口调用的入口，因为使用的是AOP，需要在程序的调用入口添加此注解，而接口方法内部抽取的方法上添加此注解是无效的；如果接口里嵌套接口，如果每个接口都添加了这个注解，那么由于嵌套，内部接口添加注解实际上是在MDC添加admin的标记，接口执行完这个标记就会清除，这样由于嵌套方法使这个注解失效，嵌套方法后的代码取消权限的注解就会失效，这种情况类似于可重入锁，进入一次锁标记加一，退出锁标记减一
15. 流程与业务分离需要注意的点：监控和补偿。 流程审批消息发送到消息队列中，各业务系统进行消息消费，通过流程类型工厂判断需要调用哪个类中的方法。例如：冻结功能审批最后一个节点审批完成后，发送审批消息，冻结审批完成需要修改冻结数量、冻结后的金额、含税金额、税额等数据，同时将修改后的数据推送到sap，整个操作加了事务。如果最后一步推送sap失败，那么事务回滚，数据也不会更新，这样就导致了审批流完结但业务数据还是审批中，造成数据不一致的问题。针对这样数据不一致的问题，解决的思路主要是进行监控和补偿。（1）	监控消息的处理，消息处理并且重试后失败，发送处理失败飞书通知，然后手动调用接口补偿处理。但这要考虑时间差的问题，如果处理的时候，流程或数据已经进入到下一个或下下一个状态，此时用就状态来更新，那么就是导致数据倒退等问题。（2）	优先保证流程和业务状态一致，那么就将推送sap放到事务之外，然后检查和补偿推送sap的操作。



订单系统总结：
1. 订单的生命周期，订单的状态流转，数据一致性问题
2. 接口设计，表结构设计，分库分表，ES，Redis，冷热数据分离，订单id生成
3. 支付，如何保证一致性，重复支付（多渠道），最终一致性（对账）


项目的难点和亮点：使用star法则进行描述
1. 三高：高并发、高性能、高可用性，最好有量化的结果，如QPS从200提升到2000，接口速度从8s优化到0.5s；高可用，监控ELK
2. 数据一致性，组件之间的一致性，在多个数据源之间的数据一致性，如缓存和DB直接数据一致性，MQ怎么保证消息不会重复消费，消息不会丢失，消息堆积如何解决
3. 库存问题，超卖，分布式锁，事务
4. 大数据量的处理：大文件的导入导出，内存溢出 CPU飙升 JVM调优 多线程
5. 大事务优化，导致死锁，锁等待超时
6. 慢查询如何优化
7. 安全性问题，鉴权、权限、加密算法、敏感词
8. 组件的升级和迁移，通用组件、日志组件
